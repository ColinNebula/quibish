<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <!-- Single Page Apps for GitHub Pages -->
    <script type="text/javascript">
      // GitHub Pages SPA redirect handling
      (function(l) {
        if (l.search[1] === '/' ) {
          var decoded = l.search.slice(1).split('&').map(function(s) { 
            return s.replace(/~and~/g, '&')
          }).join('?');
          window.history.replaceState(null, null,
              l.pathname.slice(0, -1) + decoded + l.hash
          );
        }
      }(window.location))
    </script>
    
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    
    <!-- ULTIMATE Extension Quarantine - Zero Tolerance Mode -->
    <script>
      (function() {
        'use strict';
        
        // DEFCON 1: Complete extension lockdown
        const EXTENSION_LOCKDOWN = true;
        const SAFE_ZONE_ID = 'quibish-' + Math.random().toString(36).substr(2, 9);
        
        // Create completely isolated safe zone
        window[SAFE_ZONE_ID] = {
          protectedMethods: {},
          errorCount: 0,
          blocked: []
        };
        
        // Store absolutely pristine copies immediately
        const PRISTINE = {
          find: Array.prototype.find.bind(Array.prototype),
          indexOf: String.prototype.indexOf.bind(String.prototype),
          includes: String.prototype.includes.bind(String.prototype),
          addEventListener: EventTarget.prototype.addEventListener.bind(EventTarget.prototype),
          consoleError: console.error.bind(console),
          consoleWarn: console.warn.bind(console),
          consoleLog: console.log.bind(console)
        };
        
        // Nuclear error suppression - absolute priority
        const NUCLEAR_SUPPRESS = function(event) {
          try {
            const errorInfo = {
              message: event.message || event.error?.message || '',
              filename: event.filename || event.target?.src || '',
              stack: event.error?.stack || event.reason?.stack || ''
            };
            
            const errorString = JSON.stringify(errorInfo).toLowerCase();
            
            // If ANY of these patterns match, DESTROY the error
            if (errorString.includes('contentscript') ||
                errorString.includes('extension') ||
                errorString.includes('indexof') ||
                errorString.includes('null') ||
                errorString.includes('chrome-extension') ||
                errorString.includes('moz-extension')) {
              
              window[SAFE_ZONE_ID].errorCount++;
              window[SAFE_ZONE_ID].blocked.push(errorInfo);
              
              PRISTINE.consoleWarn('� LOCKDOWN: Extension error #' + window[SAFE_ZONE_ID].errorCount + ' eliminated');
              
              // Kill the error with extreme prejudice
              if (event.preventDefault) event.preventDefault();
              if (event.stopPropagation) event.stopPropagation();
              if (event.stopImmediatePropagation) event.stopImmediatePropagation();
              
              return true;
            }
          } catch (e) {
            // Even the error handler can't fail
            PRISTINE.consoleWarn('🚫 LOCKDOWN: Error handler itself protected');
          }
          return false;
        };
        
        // Apply nuclear suppression to EVERYTHING
        try {
          // Multiple event attachment strategies
          window.addEventListener('error', NUCLEAR_SUPPRESS, true);
          window.addEventListener('unhandledrejection', NUCLEAR_SUPPRESS, true);
          document.addEventListener('error', NUCLEAR_SUPPRESS, true);
          document.addEventListener('unhandledrejection', NUCLEAR_SUPPRESS, true);
          
          // Override the error event directly
          window.onerror = function(msg, file, line, col, error) {
            if (NUCLEAR_SUPPRESS({message: msg, filename: file, error: error})) {
              return true;
            }
            return false;
          };
          
          window.onunhandledrejection = function(event) {
            return NUCLEAR_SUPPRESS(event);
          };
          
        } catch (e) {
          PRISTINE.consoleWarn('🚫 LOCKDOWN: Fallback error protection active');
        }
        
        // Bulletproof method replacement
        Array.prototype.find = function(callback, thisArg) {
          if (!callback) return undefined;
          
          try {
            const result = PRISTINE.find.call(this, function(item, index, array) {
              // Absolute null protection
              if (item === null || item === undefined) {
                return false;
              }
              
              try {
                return callback.call(thisArg, item, index, array);
              } catch (callbackError) {
                // Don't even let callback errors through
                return false;
              }
            });
            return result;
          } catch (findError) {
            // Total failure protection
            return undefined;
          }
        };
        
        String.prototype.indexOf = function(searchString, position) {
          if (this === null || this === undefined) {
            return -1;
          }
          try {
            return PRISTINE.indexOf.call(this, searchString, position);
          } catch (e) {
            return -1;
          }
        };
        
        String.prototype.includes = function(searchString, position) {
          if (this === null || this === undefined) {
            return false;
          }
          try {
            return PRISTINE.includes.call(this, searchString, position);
          } catch (e) {
            return false;
          }
        };
        
        // Console takeover
        console.error = function(...args) {
          const msg = args.join(' ').toLowerCase();
          if (msg.includes('contentscript') || 
              msg.includes('extension') || 
              msg.includes('indexof') ||
              msg.includes('null')) {
            PRISTINE.consoleWarn('� LOCKDOWN: Console error suppressed -', ...args);
            return;
          }
          PRISTINE.consoleError(...args);
        };
        
        PRISTINE.consoleWarn('� ULTIMATE LOCKDOWN ACTIVE - Extension quarantine in effect');
        
      })();
    </script>
    
    <!-- Nuclear Extension Protection - Last Resort -->
    <script>
      (function() {
        'use strict';
        
        // Nuclear option: Completely isolate extension execution
        const NUCLEAR_PROTECTION = true;
        
        // Create a sandbox for our app
        window.QUIBISH_SAFE_ZONE = {
          protectedMethods: {
            originalFind: Array.prototype.find,
            originalIndexOf: String.prototype.indexOf,
            originalIncludes: String.prototype.includes
          }
        };
        
        // Aggressive extension script blocking
        const scriptObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeType === 1) {
                // Block any script that looks like an extension
                if (node.tagName === 'SCRIPT' && 
                    (!node.hasAttribute('data-app-script') && 
                     !node.src?.includes('localhost') &&
                     !node.src?.includes('react') &&
                     !node.innerHTML?.includes('quibish'))) {
                  
                  console.warn('🚀 Nuclear protection: Extension script blocked');
                  
                  // Replace with dummy script
                  const dummy = document.createElement('script');
                  dummy.textContent = '// Extension script blocked by Quibish protection';
                  dummy.setAttribute('data-blocked-extension', 'true');
                  
                  if (node.parentNode) {
                    node.parentNode.replaceChild(dummy, node);
                  }
                }
              }
            });
          });
        });
        
        // Start nuclear protection once DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', function() {
            scriptObserver.observe(document, { childList: true, subtree: true });
          });
        } else {
          scriptObserver.observe(document, { childList: true, subtree: true });
        }
        
        // Ultimate error suppression
        const ULTIMATE_ERROR_HANDLER = function(event) {
          // If it mentions anything extension-related, kill it
          const errorText = JSON.stringify(event);
          if (errorText.includes('contentScript') ||
              errorText.includes('extension') ||
              errorText.includes('indexOf') ||
              errorText.includes('null')) {
            
            console.warn('🚀 Nuclear protection: Error eliminated');
            
            if (event.preventDefault) event.preventDefault();
            if (event.stopPropagation) event.stopPropagation();
            if (event.stopImmediatePropagation) event.stopImmediatePropagation();
            
            return true;
          }
          return false;
        };
        
        // Apply ultimate handlers to everything
        ['error', 'unhandledrejection'].forEach(eventType => {
          window.addEventListener(eventType, ULTIMATE_ERROR_HANDLER, true);
          document.addEventListener(eventType, ULTIMATE_ERROR_HANDLER, true);
        });
        
        console.warn('🚀 Nuclear extension protection activated - All extension activity blocked');
        
      })();
    </script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <meta name="theme-color" content="#6366f1" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="msapplication-TileColor" content="#6366f1" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="Quibish" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="Quibish" />
    <meta
      name="description"
      content="Quibish - A modern chat application with video calls, file sharing, GIF support, and mobile optimization"
    />
    <meta
      name="keywords"
      content="chat, messaging, video calls, file sharing, mobile, progressive web app"
    />
    
    <!-- ULTIMATE Extension Isolation Headers -->
    <meta name="robots" content="noindex, nofollow, noimageindex, noarchive, nosnippet">
    <meta name="googlebot" content="noindex, nofollow, noimageindex, noarchive, nosnippet">
    <meta name="referrer" content="no-referrer">
    <meta name="x-content-type-options" content="nosniff">
    <meta name="x-frame-options" content="SAMEORIGIN">
    
    <!-- Nuclear CSP - Block everything except our app -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: localhost:*; script-src 'self' 'unsafe-inline' 'unsafe-eval' localhost:* 'nonce-quibish-safe'; style-src 'self' 'unsafe-inline' localhost:*; img-src 'self' data: blob: https: localhost:*; connect-src 'self' localhost:* ws://localhost:* wss://localhost:*; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'self'; upgrade-insecure-requests;">
    
    <!-- Extension Blocker Meta -->
    <meta name="extension-blocker" content="active">
    <meta name="content-script-blocker" content="enabled">
    
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="%PUBLIC_URL%/logo192.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="%PUBLIC_URL%/logo192.png" />
    <link rel="apple-touch-icon" sizes="167x167" href="%PUBLIC_URL%/logo192.png" />
    
    <!-- File handling for PWA -->
    <meta name="file_handlers" content="image/*, video/*" />
    
    <!-- iOS specific meta tags -->
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="format-detection" content="telephone=no" />
    
    <!-- Prevent text selection and tap highlighting on mobile -->
    <style>
      * {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
      
      /* Allow text selection for inputs and contenteditable elements */
      [contenteditable], input, textarea {
        -webkit-user-select: auto;
        user-select: auto;
      }
    </style>
    
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Quibish - Enhanced Chat</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    
    <!-- ⚡ QUIBISH EXTENSION PROTECTION SYSTEM ⚡ -->
    <script>
      (function() {
        'use strict';
        
        // 🛡️ Nuclear-grade extension protection for Quibish
        const QUIBISH_PROTECTION = {
          
          // Extension signatures for comprehensive detection
          SIGNATURES: [
            'contentScript', 'extension-', 'chrome-extension://', 'moz-extension://',
            'safari-extension://', 'ms-browser-extension://', 'opera-extension://',
            'browser-extension', 'content_script', 'injected-script'
          ],
          
          // Error patterns commonly caused by extensions
          ERROR_PATTERNS: [
            "Cannot read properties of null (reading 'indexOf')",
            "Cannot read property 'indexOf' of null",
            "null is not an object",
            "undefined is not an object",
            "Cannot read properties of undefined",
            "Cannot read property 'includes' of null",
            "Cannot read property 'find' of null"
          ],
          
          // Check if error originates from extension
          isExtensionError: function(event) {
            // Check filename
            if (event.filename) {
              if (this.SIGNATURES.some(sig => event.filename.includes(sig))) {
                return true;
              }
            }
            
            // Check error stack
            if (event.error && event.error.stack) {
              if (this.SIGNATURES.some(sig => event.error.stack.includes(sig))) {
                return true;
              }
            }
            
            // Check error message patterns
            if (event.error && event.error.message) {
              if (this.ERROR_PATTERNS.some(pattern => event.error.message.includes(pattern))) {
                return true;
              }
            }
            
            return false;
          },
          
          // 🛡️ MINIMAL Protection (React-Safe)
          setupMinimalProtection: function() {
            // Only suppress extension console errors - don't modify prototypes
            const originalError = console.error;
            console.error = function(...args) {
              const errorStr = args.join(' ');
              if (errorStr.includes('contentScript') || 
                  errorStr.includes('extension') ||
                  (errorStr.includes('indexOf') && errorStr.includes('null'))) {
                console.warn('🛡️ Extension error suppressed:', ...args);
                return;
              }
              originalError.apply(console, args);
            };
          },
          
          // 🛡️ IMMEDIATE Error Suppression
          setupImmediateProtection: function() {
            // Catch errors immediately before they can be logged
            const immediateErrorHandler = function(event) {
              const error = event.error || event.reason;
              const filename = event.filename || '';
              const message = error?.message || event.message || '';
              
              // Check for contentScript indexOf errors specifically
              if (filename.includes('contentScript') || 
                  message.includes('Cannot read properties of null') && message.includes('indexOf') ||
                  message.includes('contentScript')) {
                
                console.warn('🛡️ IMMEDIATE: ContentScript error blocked before console:', {
                  message: message,
                  filename: filename,
                  blocked: true
                });
                
                // Prevent the error from propagating
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                return true;
              }
              
              return false;
            };
            
            // Install immediate error handlers
            window.addEventListener('error', immediateErrorHandler, true);
            window.addEventListener('unhandledrejection', immediateErrorHandler, true);
            
            console.log('🛡️ Immediate error protection activated');
          },
          
          // Light root protection (React-safe)
          protectRoot: function() {
            const root = document.getElementById('root');
            if (root) {
              root.setAttribute('data-quibish-protected', 'true');
              // Don't block innerHTML - React needs it!
            }
          },
          
          // 🚫 ENHANCED Nuclear ContentScript Isolation
          setupNuclearIsolation: function() {
            // Store original methods safely
            const originalFind = Array.prototype.find;
            const originalConsoleError = console.error;
            
            // Enhanced contentScript detection
            const isContentScriptCall = function() {
              try {
                const stack = (new Error()).stack;
                return stack && (
                  stack.includes('contentScript') ||
                  stack.includes('chrome-extension://') ||
                  stack.includes('moz-extension://') ||
                  stack.includes('safari-extension://') ||
                  stack.includes('browser-extension')
                );
              } catch (e) {
                return false;
              }
            };
            
            // Override Array.find with nuclear protection
            Array.prototype.find = function(callback, thisArg) {
              if (typeof callback !== 'function') {
                return undefined;
              }
              
              // If this is a contentScript call, use safe isolated execution
              if (isContentScriptCall()) {
                console.warn('🚫 NUCLEAR: ContentScript Array.find intercepted and blocked');
                
                // Provide safe iteration that can't throw indexOf errors
                try {
                  for (let i = 0; i < this.length; i++) {
                    const item = this[i];
                    
                    // Skip null/undefined items that cause indexOf errors
                    if (item === null || item === undefined) {
                      continue;
                    }
                    
                    try {
                      // Create ultra-safe execution environment
                      const originalIndexOf = String.prototype.indexOf;
                      
                      // Temporarily override indexOf to be null-safe
                      String.prototype.indexOf = function(searchValue, fromIndex) {
                        if (this == null) {
                          return -1;
                        }
                        return originalIndexOf.call(this, searchValue, fromIndex);
                      };
                      
                      // Execute callback in safe environment
                      const result = callback.call(thisArg, item, i, this);
                      
                      // Restore indexOf
                      String.prototype.indexOf = originalIndexOf;
                      
                      if (result) {
                        return item;
                      }
                    } catch (callbackError) {
                      console.warn('🚫 ContentScript callback error blocked:', callbackError.message);
                      continue; // Continue to next item instead of crashing
                    }
                  }
                  return undefined; // Nothing found
                } catch (error) {
                  console.warn('🚫 ContentScript iteration error blocked:', error.message);
                  return undefined;
                }
              }
              
              // Normal execution for React and legitimate code
              return originalFind.call(this, callback, thisArg);
            };
            
            // Enhanced console error filtering
            console.error = function(...args) {
              const errorStr = args.join(' ');
              
              // Block specific contentScript errors
              if (isContentScriptCall() || 
                  errorStr.includes('contentScript') ||
                  errorStr.includes('indexOf') && errorStr.includes('null') ||
                  errorStr.includes('chrome-extension://')) {
                console.warn('🚫 NUCLEAR: ContentScript error blocked:', ...args);
                return;
              }
              
              // Allow legitimate errors through
              originalConsoleError.apply(console, args);
            };
            
            console.log('🚫 Enhanced Nuclear ContentScript isolation activated');
          },
          
          // Initialize all protection systems
          initialize: function() {
            this.setupMinimalProtection();
            this.setupErrorSuppression();
            this.protectRoot();
            this.setupNuclearIsolation();
            console.log('� QUIBISH NUCLEAR PROTECTION - Complete ContentScript isolation');
          }
        };
        
        // Activate protection immediately
        QUIBISH_PROTECTION.initialize();
        
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js')
              .then((registration) => {
                console.log('✅ QUIBISH: Service Worker registered');
              })
              .catch((error) => {
                console.log('❌ QUIBISH: Service Worker registration failed:', error);
              });
          });
        }
        
      })();
    </script>
    
    <!--
      Quibish - Premium Chat Application by Nebula Media 3D
      This HTML file serves as the template for our React application.
      The build process will inject the compiled JavaScript and CSS here.
    -->
  </body>
</html>
